/*
xPi V2000 for Calculator
fx-9860G SDK Version

Copyleft 2014 xPiProject

Contributor: ExAcler, wtof1996

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

// Includes
#include <fxlib.h>
#include <stdio.h>
#include <string.h>

// Syscall function jumper
#define RTC_GetTicks() (int)(*iSysCallFuncPtr)(0,0,0,0,0x03B)

// Global variables
char sResult[2002];
double iElapsedTime;

// Syscall function base address
const int SysCallWrapper[]={0xD201422B,0x60F20000,0x80010070};
const int (*iSysCallFuncPtr)(int R4,int R5,int R6,int R7,int FNo)=(void*)&SysCallWrapper;

// Convert string into CASIO Font character set
static FONTCHARACTER* char_to_font(const char* cfname,FONTCHARACTER* ffname);

// Calc PI
int PiCalc(int c);

// xPi main procedure
int xPi(int c);

// Enter calculation digits
int EnterDigits();

int AddIn_main(int isAppli, unsigned short OptionNum)
{
    // Local variables
    unsigned int key;
	int iPiDigits=800;    // PI digits
	int iCursorPos=0;    // Highlight position

	char cDispTmpBuf[20];
	int iTmpBuf;

redraw:
    Bdisp_AllClr_DDVRAM();

	// Print options list
	locate(1,1);Print("Digits");

	memset(cDispTmpBuf,0,20);
	sprintf(cDispTmpBuf,":%d",iPiDigits);
	locate(13,1);Print(cDispTmpBuf);

	locate(1,2);Print("Start calculation");
	PrintMini(1,50,"xPi V2000 for Calculator",1);
	PrintMini(1,57,"fx-9860G SDK Version",1);

	// Highlight
	Bdisp_AreaReverseVRAM(0,8*iCursorPos,127,7+8*iCursorPos);

	while (1)
	{
	    GetKey(&key);
		switch (key)
		{
		case KEY_CTRL_UP:
		case KEY_CTRL_DOWN:
		    iCursorPos=!iCursorPos;
			goto redraw;break;
        case KEY_CTRL_EXE:
		    switch (iCursorPos)
			{
			case 0:    // Set digits
			    iTmpBuf=EnterDigits();
				if (iTmpBuf) iPiDigits=iTmpBuf;
				goto redraw;break;
			case 1:    // Start calculation
                if(iPiDigits < 4) iPiDigits = 4;
                else if(iPiDigits % 4 != 0) iPiDigits += 4 - iPiDigits % 4;
                xPi(iPiDigits/4*14);
			    goto redraw;break;
			}
        }
    }

    return 1;
}

static FONTCHARACTER* char_to_font(const char* cfname,FONTCHARACTER* ffname)
{
    int i,len=strlen(cfname);

	for(i=0;i<len;++i)
		ffname[i]=cfname[i];

	ffname[i]=0;
	return ffname;
}

int PiCalc(int c)
{
    // Local variables
    int a=10000, b,d,e,f[7001],g,h=0;
	int i;

    char sBuf[10];

    strcpy(sResult,"3.141");

	for(i=0;i<c;i++) f[i] = 2000;

	// Set timer
	iElapsedTime=RTC_GetTicks();

    for (i=0;c!=0;++i)
    {
        d=0;
        g=c<<1;
        b=c;
        while (1)
        {
            d=d+f[b]*a;
            g--;
            f[b]=d%g;
            d=d/g;
            g--;
            b--;
            if(b==0) break;
            d=d*b;
        }
        c-=14;

		memset(sBuf,0,10);
		// Skip the first four digits generated by the iteration
		if (i>0) {
            sprintf(sBuf,"%.4d",e+d/a);
		    strcat(sResult,sBuf);
        }

        e=d%a;
	}

	// Stop timer
	iElapsedTime=RTC_GetTicks()-iElapsedTime;
	iElapsedTime*=0.015625;
}

int xPi(int c)
{
    // Local variables
    int iHandle;
	int i=0;
	int key;

	char* __sResult;    // Pointer to sResult
	char sTmpBuf[20];
	FONTCHARACTER ffname[32];

	// Print start
	PopUpWin(1);
	locate(4,4);Print("Calculating...");
	Bdisp_PutDisp_DD();

	memset(sResult,0,2002);

	// Calc PI
	PiCalc(c);

	// Recreate file
	char_to_font("\\\\fls0\\PI.txt",ffname);
	Bfile_DeleteFile(ffname);
	Bfile_CreateFile(ffname,strlen(sResult));

	// Open file
	iHandle=Bfile_OpenFile(ffname,_OPENMODE_READWRITE_SHARE);
    if (iHandle<0) return 0;

	// Write file
	__sResult=sResult;
	while (*__sResult)
	{
	    sTmpBuf[0]=*__sResult++;
		sTmpBuf[1]=*__sResult++;
		sTmpBuf[2]=0;
		Bfile_WriteFile(iHandle,sTmpBuf,2);
		i+=2;
		Bfile_SeekFile(iHandle,i);
	}
    Bfile_CloseFile(iHandle);

	// Print finish
	PopUpWin(4);
	locate(4,2);Print("Complete!");
	locate(4,3);Print("Time elapsed:");
	locate(6,5);Print("Press:[EXIT]");

	memset(sTmpBuf,0,20);
	sprintf(sTmpBuf,"%.2fs",iElapsedTime);
	locate(4,4);Print(sTmpBuf);

	while (1)
	{
	    GetKey(&key);
		if (key==KEY_CTRL_EXIT)
		    return 0;
	}
}

int EnterDigits()
{
    int iInsPos;
	int key;

	char keybuff[5];

	memset(keybuff,0,5);

redraw:
	PopUpWin(2);
	locate(3,3);Print("Enter digits:");
	locate(3,4);Print("[    ]");
	locate(4,4);Print(keybuff);

	while (1)
	{
	    GetKey(&key);
		switch (key)
		{
        case KEY_CTRL_DEL:
			if (iInsPos>0)
		    {
				keybuff[--iInsPos]=0;
				goto redraw;
			}
			break;
		case KEY_CTRL_EXIT:
		    return 0;
		case KEY_CTRL_F1:
		case KEY_CTRL_EXE:
			if (iInsPos==0 || atoi(keybuff)>2000 || atoi(keybuff)<4 || atoi(keybuff)%4!=0) break;
			return atoi(keybuff);
		default:
			if (key>=0x30&&key<=0x39)
			{
				if (iInsPos<=3)
				{
					if (key==0x30&&iInsPos==0) break;
				    keybuff[iInsPos++]=key;
					goto redraw;
				}
			}
		}
	}
}

// The following source is automatically generated by the SDK. Don't modify it!
#pragma section _BR_Size
unsigned long BR_Size;
#pragma section


#pragma section _TOP

int InitializeSystem(int isAppli, unsigned short OptionNum)
{
    return INIT_ADDIN_APPLICATION(isAppli, OptionNum);
}

#pragma section

